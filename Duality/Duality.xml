<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Duality</name>
    </assembly>
    <members>
        <member name="T:Duality.SoundBudgetPriority">
            <summary>
            Defines priorities for the budget-based sound system
            </summary>
        </member>
        <member name="T:Duality.SoundBudgetPad">
            <summary>
            Wraps a SoundInstance in order to make it budget-based. Intended
            only to be used for longer sound pads.
            </summary>
        </member>
        <member name="T:Duality.DualityApp">
            <summary>
            This class controls Duality's main program flow control and general maintenance functionality.
            It initializes the engine, loads plugins, provides access to user input, houses global data structures
            and handles logfiles internally.
            </summary>
        </member>
        <member name="M:Duality.DualityApp.Init(Duality.DualityApp.ExecutionContext,System.String[])">
            <summary>
            Initializes this DualityApp. Should be called before performing any operations withing Duality.
            </summary>
            <param name="context">The <see cref="T:Duality.DualityApp.ExecutionContext"/> in which Duality runs.</param>
            <param name="args">
            Command line arguments to run this DualityApp with. 
            Usually these are just the ones from the host application, passed on.
            </param>
        </member>
        <member name="M:Duality.DualityApp.Terminate(System.Boolean)">
            <summary>
            Terminates this DualityApp. This does not end the current Process, but it isn't recommended to
            attemp performing any Duality operations after it has been terminated.
            </summary>
            <param name="unexpected">
            If true, this is handled as an unexpected termination, such as because of an exception that
            from which the application can't recover.
            </param>
        </member>
        <member name="M:Duality.DualityApp.Update">
            <summary>
            Performs a single update cycle.
            </summary>
        </member>
        <member name="M:Duality.DualityApp.Render">
            <summary>
            Performs a single render cycle.
            </summary>
        </member>
        <member name="M:Duality.DualityApp.DisposeLater(System.Object)">
            <summary>
            Schedules the specified object for disposal. It is guaranteed to be disposed by the end of the current update cycle.
            </summary>
            <param name="o">The object to schedule for disposal.</param>
        </member>
        <member name="M:Duality.DualityApp.EditorUpdate(Duality.ObjectManagers.GameObjectManager)">
            <summary>
            Performs a single editor update cycle.
            </summary>
            <param name="updateObjects"></param>
        </member>
        <member name="M:Duality.DualityApp.LoadSaveAll">
            <summary>
            Loads all <see cref="T:Duality.Resource">Resources</see> that are located in this DualityApp's data directory and
            saves them again. All loaded content is discarded both before and after this operation. You usually don't
            need this.
            </summary>
        </member>
        <member name="M:Duality.DualityApp.LoadAppData">
            <summary>
            Triggers Duality to (re)load its <see cref="T:Duality.DualityAppData"/>.
            </summary>
        </member>
        <member name="M:Duality.DualityApp.LoadUserData">
            <summary>
            Triggers Duality to (re)load its <see cref="T:Duality.DualityUserData"/>.
            </summary>
        </member>
        <member name="M:Duality.DualityApp.LoadMetaData">
            <summary>
            Triggers Duality to (re)load its <see cref="T:Duality.DualityMetaData"/>.
            </summary>
        </member>
        <member name="M:Duality.DualityApp.SaveAppData">
            <summary>
            Triggers Duality to save its <see cref="T:Duality.DualityAppData"/>.
            </summary>
        </member>
        <member name="M:Duality.DualityApp.SaveUserData">
            <summary>
            Triggers Duality to save its <see cref="T:Duality.DualityUserData"/>.
            </summary>
        </member>
        <member name="M:Duality.DualityApp.SaveMetaData">
            <summary>
            Triggers Duality to save its <see cref="T:Duality.DualityMetaData"/>.
            </summary>
        </member>
        <member name="M:Duality.DualityApp.LoadPlugins">
            <summary>
            (Re)Loads all plugins. This results in discarding ALL Resources that might have been loaded before.
            </summary>
        </member>
        <member name="M:Duality.DualityApp.ReloadPlugin(System.String)">
            <summary>
            Reloads the specified plugin. This results in discarding all <see cref="T:Duality.Resource"/> types related to this
            plugin, as well as the current <see cref="T:Duality.Resources.Scene"/>. However, you might still need to take care of your
            own custom data, i.e. dispose and properly reload it, if it relies on the reloaded plugin in any way.
            </summary>
            <param name="pluginFileName">The file path of the plugin to reload</param>
        </member>
        <member name="M:Duality.DualityApp.IsLeafPlugin(System.String)">
            <summary>
            Returns whether the specified plugin is a leaf plugin i.e. isn't referenced by any other already loaded plugin.
            </summary>
            <param name="pluginFileName">The file path of the plugin to reload</param>
            <returns></returns>
        </member>
        <member name="M:Duality.DualityApp.RequestSerializer(System.IO.Stream)">
            <summary>
            Requests a <see cref="T:Duality.Serialization.BinaryFormatter">binary serializer</see> for the specified stream.
            </summary>
            <param name="stream">The stream which is used for de/serialization</param>
            <returns>A binary serializer to use for serialization</returns>
        </member>
        <member name="M:Duality.DualityApp.GetDualityAssemblies">
            <summary>
            Enumerates all currently loaded assemblies that are part of Duality, i.e. Duality itsself and all loaded plugins.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Duality.DualityApp.GetAvailDualityTypes(System.Type)">
            <summary>
            Enumerates all available Duality <see cref="T:System.Type">Types</see> that are assignable
            to the specified Type. 
            </summary>
            <param name="baseType">The base type to use for matching the result types.</param>
            <returns>An enumeration of all Duality types deriving from the specified type.</returns>
            <example>
            The following code logs all available kinds of <see cref="T:Duality.Components.Renderer">Renderers</see>:
            <code>
            var rendererTypes = DualityApp.GetAvailDualityTypes(typeof(Duality.Components.Renderer));
            foreach (Type rt in rendererTypes)
            {
            	Log.Core.Write("Renderer Type '{0}' from Assembly '{1}'", Log.Type(rt), rt.Assembly.FullName);
            }
            </code>
            </example>
        </member>
        <member name="E:Duality.DualityApp.Initialized">
            <summary>
            Fired as soon as Duality has been initialized. However, this usually happens before creating any kind of graphics context,
            so no content is available yet and any attemp to load or request Resources is not recommended.
            </summary>
        </member>
        <member name="E:Duality.DualityApp.Terminating">
            <summary>
            Fired when shutting down Duality.
            </summary>
        </member>
        <member name="E:Duality.DualityApp.Updating">
            <summary>
            Fired once each update cycle - but not in the editor.
            </summary>
        </member>
        <member name="E:Duality.DualityApp.GfxSizeChanged">
            <summary>
            Fired whenever the <see cref="T:Duality.DualityUserData">gfx size / display resolution has changed</see>.
            </summary>
        </member>
        <member name="P:Duality.DualityApp.TargetResolution">
            <summary>
            [GET / SET] The size of the current rendering surface (full screen, a single window, etc.) in pixels. Setting this will not actually change
            Duality's state - this is a pure "for your information" property.
            </summary>
        </member>
        <member name="P:Duality.DualityApp.TargetMode">
            <summary>
            [GET / SET] The <see cref="T:OpenTK.Graphics.GraphicsMode"/> in which rendering takes place. Setting this will not actually change
            Duality's state - this is a pure "for your information" property.
            </summary>
        </member>
        <member name="P:Duality.DualityApp.Mouse">
            <summary>
            [GET / SET] Provides access to mouse user input.
            </summary>
        </member>
        <member name="P:Duality.DualityApp.Keyboard">
            <summary>
            [GET / SET] Provides access to keyboard user input
            </summary>
        </member>
        <member name="P:Duality.DualityApp.Sound">
            <summary>
            [GET] Provides access to the main <see cref="T:Duality.SoundDevice"/>.
            </summary>
        </member>
        <member name="P:Duality.DualityApp.Joysticks">
            <summary>
            [GET / SET] Provides access to joystick user input
            </summary>
        </member>
        <member name="P:Duality.DualityApp.AppData">
            <summary>
            [GET / SET] Provides access to Duality's current <see cref="T:Duality.DualityAppData">application data</see>. This is never null.
            Any kind of data change event is fired as soon as you re-assign this property. Be sure to do that after changing its data.
            </summary>
        </member>
        <member name="P:Duality.DualityApp.UserData">
            <summary>
            [GET / SET] Provides access to Duality's current <see cref="T:Duality.DualityUserData">user data</see>. This is never null.
            Any kind of data change event is fired as soon as you re-assign this property. Be sure to do that after changing its data.
            </summary>
        </member>
        <member name="P:Duality.DualityApp.MetaData">
            <summary>
            [GET] Provides access to Duality's current <see cref="T:Duality.DualityMetaData">meta data</see>. This is never null.
            </summary>
        </member>
        <member name="P:Duality.DualityApp.AppDataPath">
            <summary>
            [GET] Returns the path where this DualityApp's <see cref="T:Duality.DualityAppData">application data</see> is located at.
            </summary>
        </member>
        <member name="P:Duality.DualityApp.UserDataPath">
            <summary>
            [GET] Returns the path where this DualityApp's <see cref="T:Duality.DualityUserData">user data</see> is located at.
            </summary>
        </member>
        <member name="P:Duality.DualityApp.MetaDataPath">
            <summary>
            [GET] Returns the path where this DualityApp's <see cref="T:Duality.DualityMetaData">meta data</see> is located at.
            </summary>
        </member>
        <member name="P:Duality.DualityApp.DefaultMode">
            <summary>
            [GET] Returns the <see cref="T:OpenTK.Graphics.GraphicsMode"/> that Duality intends to use by default.
            </summary>
        </member>
        <member name="P:Duality.DualityApp.AvailableModes">
            <summary>
            [GET] Enumerates all available <see cref="T:OpenTK.Graphics.GraphicsMode">GraphicsModes</see>.
            </summary>
        </member>
        <member name="P:Duality.DualityApp.ExecContext">
            <summary>
            [GET] Returns the <see cref="T:Duality.DualityApp.ExecutionContext"/> in which this DualityApp is currently running.
            </summary>
        </member>
        <member name="P:Duality.DualityApp.LoadedPlugins">
            <summary>
            [GET] Enumerates all currently loaded plugins.
            </summary>
        </member>
        <member name="P:Duality.DualityApp.DisposedPlugins">
            <summary>
            [GET] Enumerates all plugins that have been loaded before, but have been discarded due to a runtime plugin reload operation.
            This is usually only the case when being executed from withing the editor or manually triggering a plugin reload. However,
            this is normally unnecessary.
            </summary>
        </member>
        <member name="T:Duality.DualityApp.ExecutionContext">
            <summary>
            Describes the context in which the current DualityApp runs.
            </summary>
        </member>
        <member name="F:Duality.DualityApp.ExecutionContext.Terminated">
            <summary>
            Duality has been terminated. There is no guarantee that any object is still valid or usable.
            </summary>
        </member>
        <member name="F:Duality.DualityApp.ExecutionContext.Unknown">
            <summary>
            The context in which Duality is executed is unknown.
            </summary>
        </member>
        <member name="F:Duality.DualityApp.ExecutionContext.Launcher">
            <summary>
            Duality is being run by the launcher app or similar.
            </summary>
        </member>
        <member name="F:Duality.DualityApp.ExecutionContext.Editor">
            <summary>
            Duality runs inside the editor.
            </summary>
        </member>
        <member name="M:Duality.SerializationHelper.IsSafeAssignType(System.Type)">
            <summary>
            Returns whether the specified type may just be assigned in a clone operation (even if deep)
            instead of being investigated further.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Duality.SerializationHelper.DeepResetReferences(System.Object,System.Type[])">
            <summary>
            Resets all references of object types assignable to any of the specified. typeof(Component) will
            result in all references to any kind of Component to be cleared / set null.
            </summary>
            <param name="instance"></param>
            <param name="resetTypes"></param>
        </member>
        <member name="M:Duality.SerializationHelper.DeepResolveTypeReferences(System.Object,System.Runtime.Serialization.SerializationBinder)">
            <summary>
            Re-resolves all MemberInfo references using current Type information including Plugin data. When reloading
            Plugins, calling this method for an object will re-map its previously reflected MemberInfo references to
            the newly loaded plugin Assemblies equivalent
            </summary>
            <param name="instance"></param>
        </member>
        <member name="T:Duality.Resource">
            <summary>
            The abstract Resource class is inherited by any kind of Duality content. Instances of it or one of its subclasses
            are usually handled wrapped inside a <see cref="T:Duality.ContentRef`1"/> and requested from the <see cref="T:Duality.ContentProvider"/>.
            </summary>
            <seealso cref="T:Duality.ContentRef`1"/>
            <seealso cref="T:Duality.ContentProvider"/>
        </member>
        <member name="F:Duality.Resource.FileExt">
            <summary>
            A Resource file's extension.
            </summary>
        </member>
        <member name="M:Duality.Resource.Save(System.String)">
            <summary>
            Saves the Resource to the specified path. If it has been generated at runtime, i.e. has
            not been loaded from file before, this will set the Resources <see cref="P:Duality.Resource.Path"/> Property.
            </summary>
            <param name="saveAsPath">The path to which this Resource is saved to. If null, the Resources <see cref="P:Duality.Resource.Path"/> is used as destination.</param>
        </member>
        <member name="M:Duality.Resource.Save(System.IO.Stream)">
            <summary>
            Saves the Resource to the specified stream.
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:Duality.Resource.Clone">
            <summary>
            Creates a deep copy of this Resource.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Duality.Resource.CopyTo(Duality.Resource)">
            <summary>
            Deep-copies this Resource to the specified target Resource. The target Resource's Type must
            match this Resource's Type.
            </summary>
            <param name="r">The target Resource to copy this Resource's data to</param>
        </member>
        <member name="M:Duality.Resource.OnSaving">
            <summary>
            Called when this Resource is now beginning to be saved.
            </summary>
        </member>
        <member name="M:Duality.Resource.OnSaved">
            <summary>
            Called when this Resource has just been saved.
            </summary>
        </member>
        <member name="M:Duality.Resource.OnLoaded">
            <summary>
            Called when this Resource has just been loaded.
            </summary>
        </member>
        <member name="M:Duality.Resource.Dispose">
            <summary>
            Disposes the Resource.
            </summary>
        </member>
        <member name="M:Duality.Resource.OnDisposing(System.Boolean)">
            <summary>
            Called when beginning to dispose the Resource.
            </summary>
            <param name="manually"></param>
        </member>
        <member name="M:Duality.Resource.GetContentRef">
            <summary>
            Creates a <see cref="T:Duality.ContentRef`1"/> referring to this Resource.
            </summary>
            <returns>A <see cref="T:Duality.ContentRef`1"/> referring to this Resource.</returns>
        </member>
        <member name="M:Duality.Resource.LoadResource``1(System.String)">
            <summary>
            Loads the Resource that is located at the specified path. You usually don't need this method. 
            Consider requesting the Resource from the <see cref="T:Duality.ContentProvider"/> instead.
            </summary>
            <typeparam name="T">
            Desired Type of the returned reference. Does not affect the loaded Resource in any way - it is simply returned as T.
            Results in returning null if the loaded Resource's Type isn't assignable to T.
            </typeparam>
            <param name="path">The path to load the Resource from.</param>
            <returns>The Resource that has been loaded.</returns>
        </member>
        <member name="M:Duality.Resource.LoadResource``1(System.IO.Stream,System.String)">
            <summary>
            Loads the Resource from the specified <see cref="T:System.IO.Stream"/>. You usually don't need this method. 
            Consider requesting the Resource from the <see cref="T:Duality.ContentProvider"/> instead.
            </summary>
            <typeparam name="T">
            Desired Type of the returned reference. Does not affect the loaded Resource in any way - it is simply returned as T.
            Results in returning null if the loaded Resource's Type isn't assignable to T.
            </typeparam>
            <param name="str">The stream to load the Resource from.</param>
            <param name="resPath">The path that is assumed as the loaded Resource's origin.</param>
            <returns>The Resource that has been loaded.</returns>
        </member>
        <member name="M:Duality.Resource.GetFileExtByType(System.Type)">
            <summary>
            Returns the Resource file extension for a specific Resource Type.
            </summary>
            <param name="resType">The Resource Type to return the file extension from.</param>
            <returns>The specified Resource Type's file extension.</returns>
        </member>
        <member name="M:Duality.Resource.GetTypeByFileName(System.String)">
            <summary>
            Returns the Resource Type that is associated with the specified file, based on its extension.
            </summary>
            <param name="filePath">Path to the file of whichs Resource Type will be returned</param>
            <returns>The Resource Type of the specified file</returns>
        </member>
        <member name="P:Duality.Resource.Disposed">
            <summary>
            [GET] Returns whether the Resource has been disposed. 
            Disposed Resources are not to be used and are treated the same as a null value by most methods.
            </summary>
        </member>
        <member name="P:Duality.Resource.Path">
            <summary>
            [GET] The path where this Resource has been originally loaded from or was first saved to.
            It is also the path under which this Resource is registered at the ContentProvider.
            </summary>
        </member>
        <member name="T:Duality.Time">
            <summary>
            The Time class provides a global interface for time measurement and control. It affects all time-dependent computations. 
            Use the <see cref="P:Duality.Time.TimeMult"/> Property to make your own computations time-dependent instead of frame-dependent. Otherwise, your
            game logic will depend on how many FPS the player's machine achieves and mit behave differently on very slow or fast machines.
            </summary>
        </member>
        <member name="F:Duality.Time.MsPFMult">
            <summary>
            Milliseconds a frame takes at the desired refresh rate of 60 FPS
            </summary>
        </member>
        <member name="F:Duality.Time.SPFMult">
            <summary>
            Seconds a frame takes at the desired refresh rate of 60 FPS
            </summary>
        </member>
        <member name="M:Duality.Time.Freeze">
            <summary>
            Freezes game time. This will cause the GameTimer to stop and TimeMult to equal zero.
            </summary>
        </member>
        <member name="M:Duality.Time.Resume">
            <summary>
            Unfreezes game time. TimeMult resumes to its normal value and GameTimer starts running again.
            </summary>
        </member>
        <member name="P:Duality.Time.MainTimer">
            <summary>
            [GET] Returns the number of milliseconds that have passed in real time.
            </summary>
        </member>
        <member name="P:Duality.Time.FrameBegin">
            <summary>
            [GET] MainTimer value at the beginning of the current frame
            </summary>
        </member>
        <member name="P:Duality.Time.LastDelta">
            <summary>
            [GET] Time in milliseconds the last frame took
            </summary>
        </member>
        <member name="P:Duality.Time.UpdatePerformance">
            <summary>
            [GET] Time in milliseconds the last DualityApp.Update() call took
            </summary>
        </member>
        <member name="P:Duality.Time.RenderPerformance">
            <summary>
            [GET] Time in milliseconds the last DualityApp.Render() call took
            </summary>
        </member>
        <member name="P:Duality.Time.Fps">
            <summary>
            [GET] Frames per Second
            </summary>
        </member>
        <member name="P:Duality.Time.GameTimer">
            <summary>
            [GET] Returns the number of milliseconds that have passed in game time.
            </summary>
        </member>
        <member name="P:Duality.Time.TimeMult">
            <summary>
            [GET] Multiply any frame-independend movement or change with this factor.
            It also applies the time scale you set.
            </summary>
        </member>
        <member name="P:Duality.Time.TimeScale">
            <summary>
            [GET / SET] Specifies how fast game time runs compared to real time i.e. how
            fast the game runs. May be used for slow motion effects.
            </summary>
        </member>
        <member name="P:Duality.Time.FrameCount">
            <summary>
            [GET] The number of frames passed since startup
            </summary>
        </member>
        <member name="T:Duality.LogOutputFormat">
            <summary>
            Holds log output format data that may be shared among different LogOutputs such as the
            current log indent in different outputs writing to the same file.
            </summary>
        </member>
        <member name="M:Duality.OggVorbis.OV.StreamChunk(System.IntPtr,System.IO.MemoryStream@,System.Int32@,System.Int32@)">
            <summary>
            Streams a pcm chunk from an opened ogg vorbis file to the specified OpenAL buffer.
            </summary>
            <param name="alBufferId">OpenAL buffer id to stream to</param>
            <param name="vFPtr">Ogg Vorbis file handle</param>
            <returns>Returns false, if EOF is reached.</returns>
        </member>
        <member name="M:Duality.ReflectionHelper.GetAllFields(System.Type,System.Reflection.BindingFlags)">
            <summary>
            Returns all fields matching the specified bindingflags, even if private and inherited.
            </summary>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Duality.ReflectionHelper.GetTypeName(System.Type,Duality.TypeNameFormat)">
            <summary>
            Returns a string describing a certain Type.
            </summary>
            <param name="T">The Type to describe</param>
            <param name="attrib">How to describe the Type</param>
            <returns></returns>
        </member>
        <member name="M:Duality.ReflectionHelper.FindType(System.String,System.Reflection.Assembly[],Duality.TypeNameFormat)">
            <summary>
            Retrieves a Type based on the specified TypeNameFormat
            </summary>
            <param name="typeName"></param>
            <param name="asmSearch"></param>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="T:Duality.TypeNameFormat">
            <summary>
            An enumeration of possible formats in which Type data can be displayed in a string.
            </summary>
        </member>
        <member name="F:Duality.TypeNameFormat.Keyword">
            <summary>
            The method will return a type keyword, its "short" name. Just the types "base", no generic
            type parameters or array specifications.
            </summary>
        </member>
        <member name="F:Duality.TypeNameFormat.FullNameWithoutAssembly">
            <summary>
            Exactly the same as a Types FullName, but without any Assembly names, versions, keys, etc.
            </summary>
        </member>
        <member name="F:Duality.TypeNameFormat.CSCodeIdent">
            <summary>
            A type name / definition as you would see it in normal C# code. Complete with generic parameters
            or possible array specifications.
            </summary>
        </member>
        <member name="F:Duality.TypeNameFormat.CSCodeIdentShort">
            <summary>
            As CSCodeIdent, but shortened to Keywords
            </summary>
        </member>
        <member name="T:Duality.Resources.Texture">
            <summary>
            A Texture refers to pixel data stored in video memory
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.PxDiameter">
            <summary>
            [GET] The Textures diameter
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.OglWidth">
            <summary>
            [GET] The Textures internal width as uploaded to video memory
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.OglHeight">
            <summary>
            [GET] The Textures internal height as uploaded to video memory
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.PxWidth">
            <summary>
            [GET] The Textures width after taking relative sizes into account
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.PxHeight">
            <summary>
            [GET] The Textures height after taking relative sizes into account
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.OglTexId">
            <summary>
            [GET] The Textures internal id value
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.UVRatio">
            <summary>
            [GET] UV (Texture) coordinates for the Textures lower right
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.Mipmaps">
            <summary>
            Returns whether or not the texture uses mipmaps.
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.NeedsReload">
            <summary>
            Indicates that the textures parameters have been changed in a way that might make it
            necessary to reload its data before using it next time.
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.Size">
            <summary>
            [GET / SET] The Textures (original, unadjusted) size
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.FilterMag">
            <summary>
            [GET / SET] The Textures magnifying filter
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.FilterMin">
            <summary>
            [GET / SET] The Textures minifying filter
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.WrapX">
            <summary>
            [GET / SET] The Textures horizontal wrap mode
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.WrapY">
            <summary>
            [GET / SET] The Textures vertical wrap mode
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.PixelFormat">
            <summary>
            [GET / SET] The Textures pixel format
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.OglSizeMode">
            <summary>
            [GET / SET] Handles how the Textures base Pixmap is adjusted in order to fit GPU texture size requirements (Power of Two dimensions)
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.BasePixmap">
            <summary>
            [GET / SET] Reference to a Pixmap that contains the pixel data that is or has been uploaded to the Texture
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.Atlas">
            <summary>
            [GET / SET] The Textures atlas array, distinguishing different areas in texture coordinates
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.AnimCols">
            <summary>
            [GET / SET] Information about different animation frames contained in this Texture.
            Setting this will lead to an auto-generated atlas map according to the animation.
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.AnimRows">
            <summary>
            [GET / SET] Information about different animation frames contained in this Texture.
            Setting this will lead to an auto-generated atlas map according to the animation.
            </summary>
        </member>
        <member name="P:Duality.Resources.Texture.AnimFrames">
            <summary>
            [GET] Total number of animation frames in this Texture
            </summary>
        </member>
        <member name="T:Duality.Resources.AudioData">
            <summary>
            Stores compressed audio data (Ogg Vorbis) in system memory as well as a reference to the
            OpenAL buffer containing actual PCM data, once set up. The OpenAL buffer is set up lazy
            i.e. as soon as demanded by accessing the AlBuffer property or calling SetupAlBuffer.
            </summary>
        </member>
        <member name="M:Duality.MathF.InvSqrtFast(System.Single)">
            <summary>
            Returns an approximation of a numbers inverse square root.
            </summary>
            <param name="x">A number.</param>
            <returns>An approximation of the inverse square root of the specified number, with an upper error bound of 0.001</returns>
        </member>
        <member name="M:Duality.MathF.NormalizeVar(System.Single,System.Single,System.Single)">
            <summary>
            Normalizes the given variable to the given circular area.
            Example: NormalizeVar(480, 0, 360) returns 120.
            </summary>
            <returns>The normalized value between min (inclusive) and max (exclusive).</returns>
        </member>
        <member name="M:Duality.MathF.Angle(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Calculates the angle between two points in 2D space.
            </summary>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <returns>The angle between [x1,y1] and [x2,y2] in radian measure</returns>
        </member>
        <member name="M:Duality.MathF.TurnDir(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Assuming a circular value area, this method returns the direction to "turn" value 1 to
            when it comes to take the shortest way to value 2.
            </summary>
            <param name="val1"></param>
            <param name="val2"></param>
            <param name="minVal"></param>
            <param name="maxVal"></param>
            <returns>-1 for "left" / lower, 1 for "right" / higher and 0 for "stay" / equal</returns>
        </member>
        <member name="M:Duality.MathF.CircularDist(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Calculates the distance between two values assuming a circular value area.
            </summary>
            <param name="v1">Value 1</param>
            <param name="v2">Value 2</param>
            <param name="vMin">Value area minimum</param>
            <param name="vMax">Value area maximum</param>
            <returns>Value distance</returns>
        </member>
        <member name="M:Duality.MathF.TransformCoord(System.Single@,System.Single@,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Turns and scales a specific coordinate around the specified center point
            </summary>
            <param name="xCoord"></param>
            <param name="yCoord"></param>
            <param name="rot"></param>
            <param name="scale"></param>
            <param name="xCenter"></param>
            <param name="yCenter"></param>
        </member>
        <member name="M:Duality.MathF.RectsOverlap(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Returns true, if the two specified rects overlap.
            </summary>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="w1"></param>
            <param name="h1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="w2"></param>
            <param name="h2"></param>
            <returns></returns>
        </member>
        <member name="M:Duality.MathF.GetCommonRect(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Returns the common rectangular are of both specified rectangular areas.
            </summary>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="w1"></param>
            <param name="h1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
            <param name="w2"></param>
            <param name="h2"></param>
            <param name="x3"></param>
            <param name="y3"></param>
            <param name="w3"></param>
            <param name="h3"></param>
        </member>
        <member name="M:Duality.MathF.LinesCross(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single@,System.Single@,System.Boolean)">
            <summary>
            Checks, if two line segments (or optionally an infinite lines) cross and determines their mutual point.
            </summary>
            <param name="startX1"></param>
            <param name="startY1"></param>
            <param name="endX1"></param>
            <param name="endY1"></param>
            <param name="startX2"></param>
            <param name="startY2"></param>
            <param name="endX2"></param>
            <param name="endY2"></param>
            <param name="infinite"></param>
            <param name="crossX"></param>
            <param name="crossY"></param>
            <returns>Are the lines crossing?</returns>
        </member>
        <member name="M:Duality.MathF.PointLineNearestPoint(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            Calculates the point on a line segment (or optionally an infinite line) that has the smalles possible
            distance to a seperate point.
            </summary>
            <param name="pX"></param>
            <param name="pY"></param>
            <param name="lX1"></param>
            <param name="lY1"></param>
            <param name="lX2"></param>
            <param name="lY2"></param>
            <param name="infinite"></param>
            <param name="nX"></param>
            <param name="nY"></param>
        </member>
        <member name="M:Duality.MathF.PointLineDistance(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            Calculates the distance between a point and a line segment (or optionally an infinite line)
            </summary>
            <param name="pX"></param>
            <param name="pY"></param>
            <param name="lX1"></param>
            <param name="lY1"></param>
            <param name="lX2"></param>
            <param name="lY2"></param>
            <param name="infinite"></param>
            <returns></returns>
        </member>
        <member name="M:Duality.MathF.GetLinearPrediction(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single@,System.Single@)">
            <summary>
            Assuming two objects travelling at a linear course with constant speed and angle, this method
            calculates at which point they may collide if the angle of object 1 is not defined by a specific
            (but constant!) value.
            In other words: If object 1 tries to hit object 2, let object 1 move towards the calculated point.
            </summary>
            <param name="obj1X"></param>
            <param name="obj1Y"></param>
            <param name="obj1Speed"></param>
            <param name="obj2X"></param>
            <param name="obj2Y"></param>
            <param name="obj2Speed"></param>
            <param name="obj2Angle"></param>
            <param name="colX"></param>
            <param name="colY"></param>
            <returns>
            False if it is not possible for object 1 to collide with object 2 at any course of object 1.
            This is, for example, the case if object 1 and to move to the same direction but object 2 is faster.
            A "collision point" is calculated either way, though it is not a collision point but only a 
            "directional idea" if false is returned.
            </returns>
        </member>
        <member name="M:Duality.MathF.GetLinearPrediction2(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Assuming two objects travelling at a linear course with constant speed and angle, this method
            calculates the time from now at which the distance between the two objects will be minimal. If
            this has already passed, the returned time is negative.
            </summary>
            <param name="obj1X"></param>
            <param name="obj1Y"></param>
            <param name="obj1XSpeed"></param>
            <param name="obj1YSpeed"></param>
            <param name="obj2X"></param>
            <param name="obj2Y"></param>
            <param name="obj2XSpeed"></param>
            <param name="obj2YSpeed"></param>
            <returns></returns>
        </member>
        <member name="T:Duality.Resources.Pixmap">
            <summary>
            A Pixmap stores pixel data in system memory. 
            </summary>
        </member>
        <member name="T:Duality.NonSerializedResourceAttribute">
            <summary>
            Indicates that a field will be assumed null when serializing it as part of a Resource serialization.
            </summary>
        </member>
        <member name="T:Duality.GameObject">
            <summary>
            GameObjects are what every <see cref="T:Duality.Resources.Scene"/> consists of. They represent nodes in the hierarchial scene graph and
            can maintain a <see cref="T:Duality.Resources.PrefabLink"/> connection. A GameObject's main duty is to group several <see cref="T:Duality.Component"/>s
            to form one logical instance of an actual object as part of the game, such as "Car" or "PlayerCharacter". However,
            the GameObjects itsself does not contain any game-related logic and, by default, doesn't even occupy a position in space.
            This is the job of its Components.
            </summary>
            <seealso cref="T:Duality.Component"/>
            <seealso cref="T:Duality.Resources.Scene"/>
            <seealso cref="T:Duality.Resources.PrefabLink"/>
        </member>
        <member name="M:Duality.GameObject.#ctor(Duality.ContentRef{Duality.Resources.Prefab})">
            <summary>
            Creates a GameObject based on a specific <see cref="T:Duality.Resources.Prefab"/>.
            </summary>
            <param name="prefab">The Prefab that will be applied to this GameObject.</param>
            <seealso cref="T:Duality.Resources.Prefab"/>
        </member>
        <member name="M:Duality.GameObject.LinkToPrefab(Duality.ContentRef{Duality.Resources.Prefab})">
            <summary>
            Sets or alters this GameObject's <see cref="T:Duality.Resources.PrefabLink"/> to reference the specified <see cref="T:Duality.Resources.Prefab"/>.
            </summary>
            <param name="prefab">The Prefab that will be linked to.</param>
            <seealso cref="T:Duality.Resources.PrefabLink"/>
            <seealso cref="T:Duality.Resources.Prefab"/>
        </member>
        <member name="M:Duality.GameObject.BreakPrefabLink">
            <summary>
            Breaks this GameObject's <see cref="T:Duality.Resources.PrefabLink"/>
            </summary>
        </member>
        <member name="M:Duality.GameObject.ChildAtIndex(System.Int32)">
            <summary>
            Returns the child GameObject that is internally stored at the specified index.
            </summary>
            <param name="index">The index at which the desired GameObject is located.</param>
            <returns>The child GameObject at the specified index. Null, if the index is not valid.</returns>
        </member>
        <member name="M:Duality.GameObject.ChildAtIndexPath(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Executes a series of <see cref="M:Duality.GameObject.ChildAtIndex(System.Int32)"/> calls, beginning at this GameObject and 
            each on the last retrieved child object.
            </summary>
            <param name="indexPath">An enumeration of child indices.</param>
            <returns>The last retrieved GameObject after executing all indexing steps.</returns>
            <example>
            Calling <c>ChildAtIndexPath(new[] { 0, 0 })</c> will return the first child of the first child.
            </example>
        </member>
        <member name="M:Duality.GameObject.IndexOfChild(Duality.GameObject)">
            <summary>
            Determines the index of a specific child GameObject.
            </summary>
            <param name="child">The child GameObject of which the index is to be determined.</param>
            <returns>The index of the specified child GameObject</returns>
            <seealso cref="M:Duality.GameObject.ChildAtIndex(System.Int32)"/>
        </member>
        <member name="M:Duality.GameObject.IndexPathOfChild(Duality.GameObject)">
            <summary>
            Determines the index path from this GameObject to the specified child (or grandchild, etc.) of it.
            </summary>
            <param name="child">The child GameObject to lead to.</param>
            <returns>A <see cref="T:System.Collections.Generic.List`1"/> of indices that lead from this GameObject to the specified child GameObject.</returns>
            <seealso cref="M:Duality.GameObject.ChildAtIndexPath(System.Collections.Generic.IEnumerable{System.Int32})"/>
        </member>
        <member name="M:Duality.GameObject.IsChildOf(Duality.GameObject)">
            <summary>
            Returns whether this GameObject is a child, grandchild or similar of the specified GameObject.
            </summary>
            <param name="parent">The GameObject to check whether or not it is a parent of this one.</param>
            <returns>True, if it is, false if not.</returns>
        </member>
        <member name="M:Duality.GameObject.GetComponents``1(System.Boolean)">
            <summary>
            Enumerates all <see cref="T:Duality.Component"/>s of this GameObject that match the specified <see cref="T:System.Type"/> or subclass it.
            </summary>
            <typeparam name="T">The base Type to match when iterating through the Components.</typeparam>
            <param name="activeOnly">If true, only <see cref="P:Duality.Component.Active">active</see> Components are enumerated.</param>
            <returns>An enumeration of all Components that match the specified conditions.</returns>
            <seealso cref="M:Duality.GameObject.GetComponents(System.Type,System.Boolean)"/>
        </member>
        <member name="M:Duality.GameObject.GetComponentsInChildren``1(System.Boolean)">
            <summary>
            Enumerates all <see cref="T:Duality.Component"/>s of this object's child GameObjects that match the specified <see cref="T:System.Type"/> or subclass it.
            </summary>
            <typeparam name="T">The base Type to match when iterating through the Components.</typeparam>
            <param name="activeOnly">If true, only <see cref="P:Duality.Component.Active">active</see> Components are enumerated.</param>
            <returns>An enumeration of all Components that match the specified conditions.</returns>
            <seealso cref="M:Duality.GameObject.GetComponentsInChildren(System.Type,System.Boolean)"/>
        </member>
        <member name="M:Duality.GameObject.GetComponentsDeep``1(System.Boolean)">
            <summary>
            Enumerates all <see cref="T:Duality.Component"/>s of this GameObject or any child GameObject that match the specified <see cref="T:System.Type"/> or subclass it.
            </summary>
            <typeparam name="T">The base Type to match when iterating through the Components.</typeparam>
            <param name="activeOnly">If true, only <see cref="P:Duality.Component.Active">active</see> Components are enumerated.</param>
            <returns>An enumeration of all Components that match the specified conditions.</returns>
            <seealso cref="M:Duality.GameObject.GetComponentsDeep(System.Type,System.Boolean)"/>
        </member>
        <member name="M:Duality.GameObject.GetComponents(System.Type,System.Boolean)">
            <summary>
            Enumerates all <see cref="T:Duality.Component"/>s of this GameObject that match the specified <see cref="T:System.Type"/> or subclass it.
            </summary>
            <param name="t">The base Type to match when iterating through the Components.</param>
            <param name="activeOnly">If true, only <see cref="P:Duality.Component.Active">active</see> Components are enumerated.</param>
            <returns>An enumeration of all Components that match the specified conditions.</returns>
            <seealso cref="M:Duality.GameObject.GetComponents``1(System.Boolean)"/>
        </member>
        <member name="M:Duality.GameObject.GetComponentsInChildren(System.Type,System.Boolean)">
            <summary>
            Enumerates all <see cref="T:Duality.Component"/>s of this object's child GameObjects that match the specified <see cref="T:System.Type"/> or subclass it.
            </summary>
            <param name="t">The base Type to match when iterating through the Components.</param>
            <param name="activeOnly">If true, only <see cref="P:Duality.Component.Active">active</see> Components are enumerated.</param>
            <returns>An enumeration of all Components that match the specified conditions.</returns>
            <seealso cref="M:Duality.GameObject.GetComponentsInChildren``1(System.Boolean)"/>
        </member>
        <member name="M:Duality.GameObject.GetComponentsDeep(System.Type,System.Boolean)">
            <summary>
            Enumerates all <see cref="T:Duality.Component"/>s of this GameObject or any child GameObject that match the specified <see cref="T:System.Type"/> or subclass it.
            </summary>
            <param name="t">The base Type to match when iterating through the Components.</param>
            <param name="activeOnly">If true, only <see cref="P:Duality.Component.Active">active</see> Components are enumerated.</param>
            <returns>An enumeration of all Components that match the specified conditions.</returns>
            <seealso cref="M:Duality.GameObject.GetComponentsDeep``1(System.Boolean)"/>
        </member>
        <member name="M:Duality.GameObject.GetComponent``1(System.Boolean)">
            <summary>
            Returns a single <see cref="T:Duality.Component"/> that matches the specified <see cref="T:System.Type"/>.
            </summary>
            <typeparam name="T">The Type to match the Components with.</typeparam>
            <param name="exactType">If true, the Component must match the specified Type exactly. If false, subclasses of it are also valid.</param>
            <returns>A single Component that matches the specified Type. Null, if none was found.</returns>
        </member>
        <member name="M:Duality.GameObject.GetComponent(System.Type,System.Boolean)">
            <summary>
            Returns a single <see cref="T:Duality.Component"/> that matches the specified <see cref="T:System.Type"/>.
            </summary>
            <param name="t">The Type to match the Components with.</param>
            <param name="exactType">If true, the Component must match the specified Type exactly. If false, subclasses of it are also valid.</param>
            <returns>A single Component that matches the specified Type. Null, if none was found.</returns>
        </member>
        <member name="M:Duality.GameObject.AddComponent``1">
            <summary>
            Adds a <see cref="T:Duality.Component"/> of the specified <see cref="T:System.Type"/> to this GameObject, if not existing yet.
            Simply uses the existing Component otherwise.
            </summary>
            <typeparam name="T">The Type of which to request a Component instance.</typeparam>
            <returns>A reference to a Component of the specified Type.</returns>
            <seealso cref="M:Duality.GameObject.AddComponent(System.Type)"/>
        </member>
        <member name="M:Duality.GameObject.AddComponent``1(``0)">
            <summary>
            Adds the specified <see cref="T:Duality.Component"/> to this GameObject, if no Component of that Type is already part of this GameObject.
            Simply uses the already added Component otherwise.
            </summary>
            <typeparam name="T">The Components Type.</typeparam>
            <param name="newComp">The Component instance to add to this GameObject.</param>
            <returns>A reference to a Component of the specified Type</returns>
            <exception cref="T:System.ArgumentException">Thrown if the specified Component is already attached to a GameObject</exception>
        </member>
        <member name="M:Duality.GameObject.RemoveComponent``1">
            <summary>
            Removes a <see cref="T:Duality.Component"/> of the specified <see cref="T:System.Type"/> from this GameObject, if existing.
            </summary>
            <typeparam name="T">The Type of which to remove a Component instance.</typeparam>
            <returns>A reference to the removed Component. Null otherwise.</returns>
        </member>
        <member name="M:Duality.GameObject.AddComponent(System.Type)">
            <summary>
            Adds a <see cref="T:Duality.Component"/> of the specified <see cref="T:System.Type"/> to this GameObject, if not existing yet.
            Simply uses the existing Component otherwise.
            </summary>
            <param name="t">The Type of which to request a Component instance.</param>
            <returns>A reference to a Component of the specified Type.</returns>
            <seealso cref="M:Duality.GameObject.AddComponent``1"/>
        </member>
        <member name="M:Duality.GameObject.RemoveComponent(System.Type)">
            <summary>
            Removes a <see cref="T:Duality.Component"/> of the specified <see cref="T:System.Type"/> from this GameObject, if existing.
            </summary>
            <param name="t">The Type of which to remove a Component instance.</param>
            <returns>A reference to the removed Component. Null otherwise.</returns>
        </member>
        <member name="M:Duality.GameObject.ClearComponents">
            <summary>
            Removes all <see cref="T:Duality.Component">Components</see> from this GameObject.
            </summary>
        </member>
        <member name="M:Duality.GameObject.Dispose">
            <summary>
            Disposes this GameObject as well as all of its child GameObjects and <see cref="T:Duality.Component">Components</see>.
            You usually don't need this - use <see cref="M:Duality.GameObject.DisposeLater"/> instead.
            </summary>
            <seealso cref="M:Duality.GameObject.DisposeLater"/>
        </member>
        <member name="M:Duality.GameObject.DisposeLater">
            <summary>
            Schedules this GameObject for disposal. It is guaranteed to be executed until the next update cycle starts.
            </summary>
            <seealso cref="M:Duality.GameObject.Dispose"/>
        </member>
        <member name="M:Duality.GameObject.Clone">
            <summary>
            Creates a deep copy of this GameObject.
            </summary>
            <returns>A reference to a newly created deep copy of this GameObject.</returns>
        </member>
        <member name="M:Duality.GameObject.CopyTo(Duality.GameObject)">
            <summary>
            Deep-copies this GameObject's data to the specified target GameObject.
            </summary>
            <param name="target">The target GameObject to copy to.</param>
        </member>
        <member name="P:Duality.GameObject.Parent">
            <summary>
            [GET / SET] This GameObject's parent object in the scene graph.
            A GameObject usually depends on its parent in some way, such as being
            positioned relative to it when occupying a position in space.
            </summary>
        </member>
        <member name="P:Duality.GameObject.Active">
            <summary>
            [GET / SET] Whether or not the GameObject is currently active. To return true,
            both the GameObject itsself and all of its parent GameObjects need to be active.
            </summary>
            <seealso cref="P:Duality.GameObject.ActiveSingle"/>
        </member>
        <member name="P:Duality.GameObject.ActiveSingle">
            <summary>
            [GET / SET] Whether or not the GameObject is currently active. Unlike <see cref="P:Duality.GameObject.Active"/>,
            this property ignores parent activation states and depends only on this single GameObject.
            The scene graph and other Duality instances usually check <see cref="P:Duality.GameObject.Active"/>, not ActiveSingle.
            </summary>
            <seealso cref="P:Duality.GameObject.Active"/>
        </member>
        <member name="P:Duality.GameObject.Name">
            <summary>
            [GET / SET] The name of this GameObject.
            </summary>
        </member>
        <member name="P:Duality.GameObject.FullName">
            <summary>
            [GET] The path-like hierarchial name of this GameObject.
            </summary>
            <example>For an object called <c>Wheel</c> inside an object called <c>Car</c>, this would return <c>Car/Wheel</c>.</example>
        </member>
        <member name="P:Duality.GameObject.HierarchyLevel">
            <summary>
            [GET] Returns the number of parents this object has when travelling upwards the scene graph hierarchy.
            </summary>
            <example>
            This will be zero for a root object (one that has no parent object), one for a root object's child,
            two for a root object's child's child, and so on.
            </example>
        </member>
        <member name="P:Duality.GameObject.ChildCount">
            <summary>
            [GET] The number of child GameObjects this object has.
            </summary>
        </member>
        <member name="P:Duality.GameObject.ComponentCount">
            <summary>
            [GET] The number of <see cref="T:Duality.Component"/>s this object consists of.
            </summary>
        </member>
        <member name="P:Duality.GameObject.Children">
            <summary>
            [GET] Enumerates this objects child GameObjects.
            </summary>
        </member>
        <member name="P:Duality.GameObject.ChildrenDeep">
            <summary>
            [GET] Enumerates all GameObjects that are directly or indirectly parented to this object, i.e. its
            children, grandchildren, etc.
            </summary>
        </member>
        <member name="P:Duality.GameObject.PrefabLink">
            <summary>
            [GET] The <see cref="T:Duality.Resources.PrefabLink"/> that connects this object to a <see cref="T:Duality.Resources.Prefab"/>.
            </summary>
            <seealso cref="T:Duality.Resources.PrefabLink"/>
            <seealso cref="T:Duality.Resources.Prefab"/>
        </member>
        <member name="P:Duality.GameObject.AffectedByPrefabLink">
            <summary>
            [GET] The <see cref="T:Duality.Resources.PrefabLink"/> that connects this object or one or its parent GameObjects to a <see cref="T:Duality.Resources.Prefab"/>.
            </summary>
            <remarks>
            This does not necessarily mean that this GameObject will be affected by the PrefabLink, since it might not be part of
            the linked Prefab. It simply indicates the returned PrefabLink's potential to adjust this GameObject when being applied.
            </remarks>
            <seealso cref="T:Duality.Resources.PrefabLink"/>
            <seealso cref="T:Duality.Resources.Prefab"/>
        </member>
        <member name="P:Duality.GameObject.Disposed">
            <summary>
            [GET] Returns whether this GameObject has been disposed. Disposed GameObjects are not to be used and should
            be treated specifically or as null references by your code.
            </summary>
        </member>
        <member name="P:Duality.GameObject.Transform">
            <summary>
            [GET] The GameObject's <see cref="T:Duality.Components.Transform"/> Component, if existing.
            </summary>
            <seealso cref="T:Duality.Components.Transform"/>
        </member>
        <member name="P:Duality.GameObject.Camera">
            <summary>
            [GET] The GameObject's <see cref="T:Duality.Components.Camera"/> Component, if existing.
            </summary>
            <seealso cref="T:Duality.Components.Camera"/>
        </member>
        <member name="P:Duality.GameObject.Renderer">
            <summary>
            [GET] The GameObject's <see cref="T:Duality.Components.Renderer"/> Component, if existing. 
            </summary>
            <remarks>Note that a GameObject may contain multiple Renderers in which case the return value of this property may be any of them.</remarks>
            <seealso cref="T:Duality.Components.Renderer"/>
        </member>
        <member name="E:Duality.GameObject.EventComponentAdded">
            <summary>
            Fired when a Component has been added to the GameObject
            </summary>
        </member>
        <member name="E:Duality.GameObject.EventComponentRemoving">
            <summary>
            Fired when a Component is about to be removed from the GameObject
            </summary>
        </member>
        <member name="M:Duality.ContentRef`1.MakeAvailable">
            <summary>
            Loads the associated content as if it was accessed now.
            You don't usually need to call this method. It is invoked implicitly by trying to access the ContentRef/>
            </summary>
        </member>
    </members>
</doc>
