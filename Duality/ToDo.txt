
-->	Duality Tasks (overall)
	-->	Physics & Collision Detection
	-->	Particle Systems & Particle Editor
	-->	(Property) Animations & Animation Editor
	-->	??? Ingame GUI & GUI Editor
	-->	??? Editor: Xml Serialization and "export game (binary)" functionality


-->	Implement "Create Poly" action
	-->	Prevent non-convex polys
	-->	Testing
--> Collision event handling (Core)
	-->	Interpret data
	-->	Wrap up data, cache it until Update() and then notify GameObject
-->	Physics utility
	-->	Collider.ApplyForce()		linear / angular	local / world
	-->	Collider.ApplyImpulse()		linear / angular	local / world
	-->	Collider.GetVelocityAt()						local / world
-->	Re-Implement Asteroids with physics.






-->	How would you do.. (All those should be possible in some way!)
	-->	.. a platformer with moving platforms?
	-->	.. an Rpg using Tilemaps?
	-->	.. a complex character / ragdoll?
	-->	.. a complex vehicle (tank, walker, etc.)
	-->	.. a hanging bridge, rope, etc?

-->	Implement Core collision detection logic & sensor colliders
	-->	Colliders will notify their GameObject about OnCollision, OnSeparation and AfterCollision..
	-->	..which will then notify its ICmpCollisionListener Components.
	-->	It may only cache / defer this until it is updated, since all those events aren't meant
		to directly execute user code. It might lead to unexpected behaviour.
	-->	Deferred execution should take place in Collider code, OnXY notifier should directly execute.
		Reason: There might be different kinds of collider components later.
		-->	Collider (default)
		-->	TilemapCollider
			-->	Well, this could actually be just a bool flag for a Tilemap, auto-adjusting a separate collider.
		-->	...

	ICmpCollisionListener API:
	-->	OnCollisionBegin(CollisionData objA, CollisionData objB);
	-->	OnCollisionSolve(CollisionData objA, CollisionData objB, ContactData contact);
	-->	OnCollisionEnd(CollisionData objA, CollisionData objB);
	-->	This is not final. Reconsider it based on actual use cases.
	-->	"CollisionData" is not figured out yet.
		-->	It might contain only Duality-related data and act as if there was no Farseer
		-->	This is preferrable since replacing Farseer with a different physics engine
			won't affect any user code. Encapsulation rulez.

	-->	Collision impact force?
	-->	Collision point relative to object?
	-->	How to interpret Farseer Data?

-->	What about Joints?
	-->	Any Collider can be attached to the world or any other Collider using Joints.
		This is NOT a scene-hierarchial thing.
	-->	Handle joints as some kind of property of a Collider, since any Joint will be
		attached to at least one Collider.
	-->	WYSIWYG-Editor for those joints as well when CamView in Collider edit mode.
	-->	Complex physical objects can be composed out of several parented GameObjects.
		They can also be done using custom Components, but likely won't.






-->	Isometric perspective: How to implement for a game?
	-->	Should actually use the Z Component, but apply it other than currently
	-->	Maybe just utilize PreprocessCoords to add Z to Y?
		-->	Will that work in all cases? Editor? Canvas? Any Renderer?

-->	Keep in mind: Saving GameObjects with PrefabLinks is currently highly data-redundant.
	-->	When in ExecutionContext.Editor, consider not saving Components that are part of the Prefab.
	-->	Can't do the same with GameObjects though, because their index is used to locate them when applying
		the PrefabLink. Changing the order or removing existing GameObjects requires extra consideration.


############### HOWTO: Obtain the Z-Pos of a rendered pixel relative to the Camera ###############

//Vector3 screenPos = new Vector3(0.5f, 0.5f, 0.0f);
//GL.ReadPixels(this.pickingTex.PxWidth / 2, this.pickingTex.PxHeight / 2, 1, 1, PixelFormat.DepthComponent, PixelType.Float, ref screenPos.Z);
//screenPos -= Vector3.One * 0.5f;
//screenPos *= 2.0f;
//Matrix4 matTemp = this.matFinal;
//matTemp.Invert();
//Vector3.Transform(ref screenPos, ref matTemp, out screenPos);
//Log.Editor.Write("{0:F},\t{1:F},\t{2:F}", screenPos.X, screenPos.Y, screenPos.Z);