
Next Steps:
1.	Bugfixing
2.	Collider Editor
3.	Collider Logic (Core)
4.	Re-Implement Asteroids using Colliders
5.	"Optional": Collider Joints (Editor & Logic)

-->	How to implement "Create Circle" / "Create Poly" actions?
	-->	Introduce new CamViewState.CursorHandler class
	-->	The basic one handles all standard MouseActions and CameraActions
	-->	"Create Circle" and "Create Polygon" both create and inject their own CursorHandler
	-->	...which handles shape creation

-->	WYSIWYG-Editor for Collider Shapes
	-->	Preview shape in view
		-->	Display a shapes density numeric (absolute value) and visually as fill transparency (relative to other shapes)
		-->	Display the shapes index in the shape list!

	-->	Edit shape in view
		-->	Introduce Shapes-Property (For Prefabs) & properly react to setting it
			-->	Keep in mind: Unregister all old pseudo-body (fixture, really) events, re-register them afterwards
		-->	Circles
		-->	Polygons
			-->	Only allow only convex polygons!

	-->	Implement IsSensor and make it editable

	-->	Edit Joints in view
		-->	Click (set point A), Click (set point B)
		-->	Highlight hovered Collider (to which the Joint is attached, defaults to "world" --> fixed joint)

-->	How would you do.. (All those should be possible in some way!)
	-->	.. a platformer with moving platforms?
	-->	.. an Rpg using Tilemaps?
	-->	.. a complex character / ragdoll?
	-->	.. a complex vehicle (tank, walker, etc.)
	-->	.. a hanging bridge, rope, etc?


-->	Implement Core collision detection logic & sensor colliders
	-->	Colliders will notify their GameObject about OnCollision, OnSeparation and AfterCollision..
	-->	..which will then notify its ICmpCollisionListener Components.
	-->	It may only cache / defer this until it is updated, since all those events aren't meant
		to directly execute user code. It might lead to unexpected behaviour.
	-->	Deferred execution should take place in Collider code, OnXY notifier should directly execute.
		Reason: There might be different kinds of collider components later.
		-->	Collider (default)
		-->	TilemapCollider
			-->	Well, this could actually be just a bool flag for a Tilemap, auto-adjusting a separate collider.
		-->	...

	ICmpCollisionListener API:
	-->	OnCollisionBegin(CollisionData objA, CollisionData objB);
	-->	OnCollisionSolve(CollisionData objA, CollisionData objB, ContactData contact);
	-->	OnCollisionEnd(CollisionData objA, CollisionData objB);
	-->	This is not final. Reconsider it based on actual use cases.
	-->	"CollisionData" is not figured out yet.
		-->	It might contain only Duality-related data and act as if there was no Farseer
		-->	This is preferrable since replacing Farseer with a different physics engine
			won't affect any user code. Encapsulation rulez.

	-->	Collision impact force?
	-->	Collision point relative to object?
	-->	How to interpret Farseer Data?

	-->	What about Joints?
		-->	Any Collider can be attached to the world or any other Collider using Joints.
			This is NOT a scene-hierarchial thing.
		-->	Handle joints as some kind of property of a Collider, since any Joint will be
			attached to at least one Collider.
		-->	WYSIWYG-Editor for those joints as well when CamView in Collider edit mode.
		-->	Complex physical objects can be composed out of several parented GameObjects.
			They can also be done using custom Components, but likely won't.
	
	-->	Is that wanted behaviour? How is Unity doing all that..?

-->	Implement raycasting & stuff (Rebuild some Farseer Example with object click&drag)
-->	Port Asteroids demo to a physics-driven version, without any manual collision detection




-->	Duality Tasks (overall)
	-->	Physics & Collision Detection
	-->	Particle Systems & Particle Editor
	-->	Ingame GUI & GUI Editor
	-->	(Property) Animations & Animation Editor




-->	Isometric perspective: How to implement for a game?
	-->	Should actually use the Z Component, but apply it other than currently
	-->	Maybe just utilize PreprocessCoords to add Z to Y?
		-->	Will that work in all cases? Editor? Canvas? Any Renderer?

-->	Keep in mind: Saving GameObjects with PrefabLinks is currently highly data-redundant.
	-->	When in ExecutionContext.Editor, consider not saving Components that are part of the Prefab.
	-->	Can't do the same with GameObjects though, because their index is used to locate them when applying
		the PrefabLink. Changing the order or removing existing GameObjects requires extra consideration.