
-->	Duality Tasks (overall)
	-->	Particle Systems & Particle Editor
	-->	Scripts (Each deriving from Script-Baseclass)
	-->	(Property) Animations & Animation Editor
	-->	??? Ingame GUI & GUI Editor

-->	Dualitor: PerformanceMonitor
-->	Dualitor: Component Wizard
-->	Dualitor: Improve User learning curve
	-->	More Advisor information?
	-->	"Did you know..?" screen?

	
--> Joints and Joint Editors
	-->	Create JointInfo classes for all relevant Farseer Joints
		-->	Line
		-->	Pulley
		-->	Slider
	-->	Display dual and single JointInfos in ColliderEditor
	-->	Make some of them editable there?

-->	Physics Raycast

-->	Replace Acceptedcategories in ObjectInspector with clever algorithm
	-->	When there are multiple ObjectInspectors and a selection has occured,
		instead of just updating all unlocked selections, only do that in one
		single ObjectInspector
	-->	Select the one ObjectInspector that shares the new selections category
		-->	Without ObjectSelection.Category: That has the best base class match.
	-->	If more than one ObjectInspector share the same match score, select
		the one with the lowest "steal selection" counter. Increase its counter.
	-->	Reconsider ObjectSelection.Category. Replace by simple "base class" mechanic?
		-->	Would be much more flexible!
		-->	Could still provide some hardcoded Categories via static readonly fields.
	-->	Test with one, two or three ObjectInspectors.

--> Reconsider "events" in Duality.
	-->	Are they really necessary?
	-->	Do they lead to difficult design on the user-side?
	-->	Pros
	-->	Cons

-->	Implement some simple Font effects?


-->	Example Project: Super Mario style platformer
	-->	Tile-based
	-->	Will need something to edit tilemaps and probably a distinct Tileset Resource
	-->	Component: TilemapRenderer
	-->	Component: TilemapCollider
	-->	Resource: Tileset
		-->	References Material to use
		-->	Defines tile data
			-->	Collision Group (0 == dont collide)
			-->	Collision mask (Top, Bottom, Left, Right) (?)
			-->	Is AutoTile?
			-->	etc.
	-->	CamViewState: Tile Editor (?)
	-->	Is there a way to generalize all this enough to make dynamically lit tilemap rendering
		blend into existing design  smoothly?



		
		
		
-->	Concept for "Component Wizard" dialog / editor:
	Das bezieht sich natürlich nicht auf deinen Grundgedanken sondern auf die Implikationen, welche das Bild das ich vom Feature Request insgesamt gewonnen habe mit sich bringt. Insofern würd ich erstmal sagen "Nein, so in der Form halte ich das für keine gute Idee", was aber nichts am Problem ändert das dein Feature hätte lösen sollen. Folgendes wäre ein alternativer Ansatz, den ich mir gut vorstellen könnte:

	--> Implementierung eines neuen Sub-Editors oder Dialogfelds, dem "Component Wizard" (o.Ä.)
	--> Aufgabe dessen ist es, auf Basis einiger Angaben, z.B. einer Auflistung von Property-Definitionen eine Komponentenklasse im Projekt zu erstellen. 
	--> Dabei können dann auch so Späße getrieben werden wie automatisch die Backend-Fields generieren, triviale Getter und Setter implementieren und sowas. Das Ergebnis wird als .cs-Code File im Projekt abgelegt und über Bearbeitung der Projektdatei automatisch hinzugefügt.
	--> Wenn es mir gelingt, über Dualitor Visual Studio dazu zu bewegen, ein bestimmtes Projekt neu zu kompilieren, dann könnte der Component Wizard auch das automatisch veranlassen, sobald die neue Komponentenklasse erstellt wurde
	--> Ist letzteres der Fall wäre es denkbar, im Editor einige Shortcuts einzufügen, die den Component Wizard aufrufen, z.B. direkt im PropertyGrid oder als Rechtsklick-Aktion auf ein GameObject. 

	Im Idealfall wäre der Ablauf also:
	1. GameObject (z.B. Asteroid) erstellen und damit rumbasteln bis zufrieden
	2. Rechtsklick auf GameObject --> "Add custom Component" --> Component Wizard wird aufgerufen
	3. Gewünschte Konfiguration im Component Wizard festlegen
	4. Klick auf "Ok" sorgt für Neukompilierung des Core Plugins, was automatisch zum Neuladen dieses führt
	5. Anschließend kann der neue Komponententyp per Reflection gefunden und automatisch an das GameObject angefügt werden.

	Die Schritte 4 und 5 können natürlich nur umgesetzt werden, wenn ich diese Sache mit Visual Studio ansteuern hinbekomme. Mir ist zwar klar dass ich auch programmatisch ohne Probleme C# Code kompilieren kann, aber effektiv würde ich mit dem manuellen Versuch schon wieder eine neue Baustelle für mögliche Inkonsistenzen einführen, falls ich ein bestimmtes Verhalten in Bezug auf Projektkonfiguration falsch (oder anders als Visual Studio) emuliere. Von daher würde ich hier klar sagen "entweder VS selbst kompilieren lassen oder gar nicht".
		
		
		
		
		


-->	Isometric perspective: How to implement for a game?
	-->	Should actually use the Z Component, but apply it other than currently
	-->	Maybe just utilize PreprocessCoords to add Z to Y?
		-->	Will that work in all cases? Editor? Canvas? Any Renderer?
	-->	Is it really necessary to adjust the Camera? Isn't it possible to 
		adjust objects and rendering setup on the Game-side?

-->	Keep in mind: Saving GameObjects with PrefabLinks is currently highly data-redundant.
	-->	When in ExecutionContext.Editor, consider not saving Components that are part of the Prefab.
	-->	Can't do the same with GameObjects though, because their index is used to locate them when applying
		the PrefabLink. Changing the order or removing existing GameObjects requires extra consideration.


############### HOWTO: Obtain the Z-Pos of a rendered pixel relative to the Camera ###############

//Vector3 screenPos = new Vector3(0.5f, 0.5f, 0.0f);
//GL.ReadPixels(this.pickingTex.PxWidth / 2, this.pickingTex.PxHeight / 2, 1, 1, PixelFormat.DepthComponent, PixelType.Float, ref screenPos.Z);
//screenPos -= Vector3.One * 0.5f;
//screenPos *= 2.0f;
//Matrix4 matTemp = this.matFinal;
//matTemp.Invert();
//Vector3.Transform(ref screenPos, ref matTemp, out screenPos);
//Log.Editor.Write("{0:F},\t{1:F},\t{2:F}", screenPos.X, screenPos.Y, screenPos.Z);