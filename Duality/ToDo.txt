
-->	Duality Tasks (overall)
	-->	Particle Systems & Particle Editor
	-->	Scripts (Each deriving from Script-Baseclass)
	-->	(Property) Animations & Animation Editor
	-->	??? Ingame GUI & GUI Editor

-->	Dualitor: PerformanceMonitor

--> Reconsider "events" in Duality.
	-->	Are they really necessary?
	-->	Do they lead to difficult design on the user-side?
	-->	Pros
	-->	Cons

-->	Implement some simple Font effects?

-->	Testing, Testing, Testing! Only a dead bug is a good bug.



-->	TrommlBomml Feedback
	-->	If editoruserdata.xml doesn't exist, provide a default user data.
	-->	Add CamViewLayer "Grid", might be active by default. Probably highlight origin coordiante (0,0,0)
	-->	Consider not showing Components in the Scene View. Optionally, that is.


-->	Dualitor: Add ActionButtonPropertyEditor and auto-use it in MemberwisePropertyEditor
	-->	It's possible to flag a method as editor action via EditorHintFlags
	-->	This method becomes an additional ActionButtonPropertyEditor
	-->	Which is itself a GroupedPropertyEditor with an execute-button
	-->	Parameters to use are child-Properties
	-->	Add this whole functionality in PropertyGrid-Project itself?
		-->	Can't. It requires EditorHintFlags.
		-->	Also, this here will prove / assure PropertyGrids customization support


-->	AnimSpriteRenderer
	-->	Feature: CustomFrameSequence (supported by existing anim modes)
	-->	Feature: Queue anim mode, treating the CustomFrameSequence as queue and
		interpreting the AnimationDuration as a single frame's time.


-->	Dualitor: Upgrade LogView with a Console (or separate both?)
	-->	Can parse single-line commands
	-->	Expression Result is printed in the console (!= logged), if not defined otherwise.
	-->	Use expression trees, Reflection or actually compile code?
	-->	Executed on a Console-internal dynamic object (Expando-Object or similar)
		-->	Can define and use custom Methods and Properties
			-->	See also: http://www.rickardnilsson.net/post/2012/01/01/csharp-repl-and-interactive-interpreter.aspx
		-->	Some predefined commands are always available and can't be overwritten
		-->	When accessing Properties that do not exist, try to intepret them as GameObjects / Components / Resources


-->	Dualitor: Component Wizard
	-->	See below for dialog concept
	-->	Implement in a separate plugin so it is possible to opt-out.
	-->	Work based on a "Parse and Write C# Code" approach
		-->	CodeDomProvider.Parse Method
		-->	CodeDomProvider.GenerateCodeFromCompileUnit Method
		-->	Unfortunately, DotNet doesn't implement the parse method.
		-->	Use NRefactory instead?
			-->	Pro: Seems to be really, really good at what it does
			-->	Pro: Could provide really cool "Here, let me edit your code for you" features
			-->	Con: It's huge.
		-->	Test this approach before by replacing all currently existing C# code interaction with it
			-->	Measure how fast it is. Is it performant enough?
			-->	Compare to current solution.
	-->	Use MsBuild to auto-rebuild core plugins (not the whole solution)
	-->	Also provide editing for existing Components (Rightclick ..> Edit)
		-->	Shortcut-Shortcut: Rightclick --> Add Property...


		
	
		
-->	Concept for "Component Wizard" dialog / editor:
	Das bezieht sich natürlich nicht auf deinen Grundgedanken sondern auf die Implikationen, welche das Bild das ich vom Feature Request insgesamt gewonnen habe mit sich bringt. Insofern würd ich erstmal sagen "Nein, so in der Form halte ich das für keine gute Idee", was aber nichts am Problem ändert das dein Feature hätte lösen sollen. Folgendes wäre ein alternativer Ansatz, den ich mir gut vorstellen könnte:

	--> Implementierung eines neuen Sub-Editors oder Dialogfelds, dem "Component Wizard" (o.Ä.)
	--> Aufgabe dessen ist es, auf Basis einiger Angaben, z.B. einer Auflistung von Property-Definitionen eine Komponentenklasse im Projekt zu erstellen. 
	--> Dabei können dann auch so Späße getrieben werden wie automatisch die Backend-Fields generieren, triviale Getter und Setter implementieren und sowas. Das Ergebnis wird als .cs-Code File im Projekt abgelegt und über Bearbeitung der Projektdatei automatisch hinzugefügt.
	--> Wenn es mir gelingt, über Dualitor Visual Studio dazu zu bewegen, ein bestimmtes Projekt neu zu kompilieren, dann könnte der Component Wizard auch das automatisch veranlassen, sobald die neue Komponentenklasse erstellt wurde
	--> Ist letzteres der Fall wäre es denkbar, im Editor einige Shortcuts einzufügen, die den Component Wizard aufrufen, z.B. direkt im PropertyGrid oder als Rechtsklick-Aktion auf ein GameObject. 

	Im Idealfall wäre der Ablauf also:
	1. GameObject (z.B. Asteroid) erstellen und damit rumbasteln bis zufrieden
	2. Rechtsklick auf GameObject --> "Add custom Component" --> Component Wizard wird aufgerufen
	3. Gewünschte Konfiguration im Component Wizard festlegen
	4. Klick auf "Ok" sorgt für Neukompilierung des Core Plugins, was automatisch zum Neuladen dieses führt
	5. Anschließend kann der neue Komponententyp per Reflection gefunden und automatisch an das GameObject angefügt werden.

	Die Schritte 4 und 5 können natürlich nur umgesetzt werden, wenn ich diese Sache mit Visual Studio ansteuern hinbekomme. Mir ist zwar klar dass ich auch programmatisch ohne Probleme C# Code kompilieren kann, aber effektiv würde ich mit dem manuellen Versuch schon wieder eine neue Baustelle für mögliche Inkonsistenzen einführen, falls ich ein bestimmtes Verhalten in Bezug auf Projektkonfiguration falsch (oder anders als Visual Studio) emuliere. Von daher würde ich hier klar sagen "entweder VS selbst kompilieren lassen oder gar nicht".
		
		
		
		
		


-->	Isometric perspective: How to implement for a game?
	-->	Should actually use the Z Component, but apply it other than currently
	-->	Maybe just utilize PreprocessCoords to add Z to Y?
		-->	Will that work in all cases? Editor? Canvas? Any Renderer?
	-->	Is it really necessary to adjust the Camera? Isn't it possible to 
		adjust objects and rendering setup on the Game-side?

-->	Keep in mind: Saving GameObjects with PrefabLinks is currently highly data-redundant.
	-->	When in ExecutionContext.Editor, consider not saving Components that are part of the Prefab.
	-->	Can't do the same with GameObjects though, because their index is used to locate them when applying
		the PrefabLink. Changing the order or removing existing GameObjects requires extra consideration.


############### HOWTO: Obtain the Z-Pos of a rendered pixel relative to the Camera ###############

//Vector3 screenPos = new Vector3(0.5f, 0.5f, 0.0f);
//GL.ReadPixels(this.pickingTex.PxWidth / 2, this.pickingTex.PxHeight / 2, 1, 1, PixelFormat.DepthComponent, PixelType.Float, ref screenPos.Z);
//screenPos -= Vector3.One * 0.5f;
//screenPos *= 2.0f;
//Matrix4 matTemp = this.matFinal;
//matTemp.Invert();
//Vector3.Transform(ref screenPos, ref matTemp, out screenPos);
//Log.Editor.Write("{0:F},\t{1:F},\t{2:F}", screenPos.X, screenPos.Y, screenPos.Z);