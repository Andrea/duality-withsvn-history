
-->	Serialization ToDo
	-->	Implement BinaryMetaFormatter writing and assure 100% compatibility with BinaryFormatter
	-->	Expose TypeDataLayout as special TypeDataLayout node when first read.
	-->	Goal: Open damaged binary files with MetaFormatter, repair them manually, save them.
		-->	Provide a Dualitor-Plugin that allows opening, editing and saving .res files based on
			the MetaFormatters data node tree.
		-->	First step: Just opening, viewing and saving
		-->	Second step: Editing

	-->	React to [System.Serializable], [System.NonSerialized] and [Duality.Resources.NonSerializedPrefab]
	-->	Custom object serialization / Duality.Serialization.ISerializable interface, Pixmap needs it and probably others as well

	-->	Not quite sure / optional / even harmful?
		-->	Consider reacting to 
			[System.Runtime.Serialization.OnDeserializing], 
			[System.Runtime.Serialization.OnDeserialized], 
			[System.Runtime.Serialization.OnSerializing] and 
			[System.Runtime.Serialization.OnSerialized]
		-->	Consider reacting to System.Runtime.Serialization.IDeserializationCallback interface

	-->	Test if it can de/serialize Duality stuff properly
	-->	Port content to new serialization format
	-->	Stability test when reloading core plugins (Are Types resolved properly using FindType?)
	-->	Performance optimization
		-->	FindType.

	--> Get rid of (old) SerializationHelper.
	


-->	Editor Skeletton
	-->	Sandbox (Play | Pause | Reset)


-->	Keep in mind: Saving GameObjects with PrefabLinks is currently highly data-redundant.
	-->	When in ExecutionContext.Editor, consider not saving Components that are part of the Prefab.
	-->	Can't do the same with GameObjects though, because their index is used to locate them when applying
		the PrefabLink. Changing the order or removing existing GameObjects requires extra consideration.

-->	Keep in mind: Currently, DeepResolveTypeReferences is invoked on ANY loaded Resource, no matter if its loaded
	in the editor or not. 
	-->	This is kind of a "stability hack": In theory, this is only necessary in ExecutionContext.Editor, because Plugins 
		won't change at run-time. However, in practice the user may run the game from the editor and step into a Resource 
		the editor hasn't loaded so far and thus didn't resolve its type references. While it normally works, it will 
		result in undefined behaviour when a core plugin has changed since the Resource has been saved the last time.
	-->	It would be sufficient to resolve type references of all existing Resources at once when building the game for
		release mode i.e. "closing the source code".
	-->	Though, as long as it doesn't become a performance issue, it may stay like this.
	-->	Solution notes, given the case it DOES become a performance issue:
		-->	It would be possible to provide a "plugin hash" in the basic Resource class. Resolving type references
			is only necessary if the current (DualityApp's) plugin hash differs from the one saved in the Resource.
			It might then be performed automatically and also save the Resource again so it won't be necessary a 
			second time until rebuilding plugins again.

-->	Keep in mind: While reloading Core plugins at runtime does work fine in most cases, it might result in
	undefined behaviour when custom Resource types have been modified, as only Prefabs and the current level
	are reloaded.
	-->	Possible solution: Scan the reloaded core plugin for classes deriving from Resource, and clear all
		Resources matching their Type as well.