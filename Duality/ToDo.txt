
-->	Duality Tasks (overall)
	-->	Particle Systems & Particle Editor
	-->	(Property) Animations & Animation Editor
	-->	??? Ingame GUI & GUI Editor

-->	Dualitor: PerformanceMonitor
-->	Dualitor: Completely rework PropertyEditors?
	-->	Goals: Performance, Style
	-->	Experiment externally first!
	-->	Single Control (Grid), PropertyEditor not deriving from "Control"-stuff, custom Drawing, custom Layout




-->	How would you do.. (All those should be possible in some way!)
	-->	.. a platformer with moving platforms?
	-->	.. an Rpg using Tilemaps?
	-->	.. a complex character / ragdoll?
	-->	.. a complex vehicle (tank, walker, etc.)
	-->	.. a hanging bridge, rope, etc?

-->	What about Joints?
	-->	Any Collider can be attached to the world or any other Collider using Joints.
		This is NOT a scene-hierarchial thing.
	-->	Handle joints as some kind of property of a Collider, since any Joint will be
		attached to at least one Collider.
	-->	WYSIWYG-Editor for those joints as well when CamView in Collider edit mode.
	-->	Complex physical objects can be composed out of several parented GameObjects.
		They can also be done using custom Components, but likely won't.






-->	Isometric perspective: How to implement for a game?
	-->	Should actually use the Z Component, but apply it other than currently
	-->	Maybe just utilize PreprocessCoords to add Z to Y?
		-->	Will that work in all cases? Editor? Canvas? Any Renderer?

-->	Keep in mind: Saving GameObjects with PrefabLinks is currently highly data-redundant.
	-->	When in ExecutionContext.Editor, consider not saving Components that are part of the Prefab.
	-->	Can't do the same with GameObjects though, because their index is used to locate them when applying
		the PrefabLink. Changing the order or removing existing GameObjects requires extra consideration.


############### HOWTO: Obtain the Z-Pos of a rendered pixel relative to the Camera ###############

//Vector3 screenPos = new Vector3(0.5f, 0.5f, 0.0f);
//GL.ReadPixels(this.pickingTex.PxWidth / 2, this.pickingTex.PxHeight / 2, 1, 1, PixelFormat.DepthComponent, PixelType.Float, ref screenPos.Z);
//screenPos -= Vector3.One * 0.5f;
//screenPos *= 2.0f;
//Matrix4 matTemp = this.matFinal;
//matTemp.Invert();
//Vector3.Transform(ref screenPos, ref matTemp, out screenPos);
//Log.Editor.Write("{0:F},\t{1:F},\t{2:F}", screenPos.X, screenPos.Y, screenPos.Z);