
Next Steps:
1.	Bugfixing
2.	Collider Editor
3.	Collider Logic (Core)
4.	Re-Implement Asteroids using Colliders
5.	"Optional": Collider Joints (Editor & Logic)

-->	Bug: TreeViewAdvs FilteredTreeModel doesn't properly map InnerModel events to external events.
	This results in de-selection any time the model changes (add / remove / change)
	-->	Properly implement this
	-->	Alternatively, workaround this

-->	Bug: Changing the Component type (adding new interface, etc.) doesn't update a Scene's managers.
	-->	Keep in mind: Scenes that aren't loaded need to be updated as well.
	-->	Don't save managers / change Scene serialization? Needs to be more robust!

-->	WYSIWYG-Editor for Collider Shapes
	-->	Probably make ShapeInfo-selection editor-global, so it can be edited in the Resource Inspector
	-->	Each ShapeInfo has Density and IsSensor, at least. How would you edit them otherwise?
	-->	Well, there probably is a way for these two. Figure something out.

	-->	Preview shape in view
		-->	Display a shapes density numeric (absolute value) and visually as fill transparency (relative to other shapes)
		-->	Display the shapes index in the shape list!

	-->	Edit shape in view
		-->	Introduce Shapes-Property (For Prefabs) & properly react to setting it
			-->	Keep in mind: Unregister all old pseudo-body (fixture, really) events, re-register them afterwards
		-->	Circles
		-->	Polygons
			-->	May be any kind of shape and vertex number.
			-->	Use some kind of decomposition (internally!) to create a set of valid Farseers polygons.

	-->	Edit Joints in view
		-->	Click (set point A), Click (set point B)
		-->	Highlight hovered Collider (to which the Joint is attached, defaults to "world" --> fixed joint)

-->	How would you do.. (All those should be possible in some way!)
	-->	.. a platformer with moving platforms?
	-->	.. an Rpg using Tilemaps?
	-->	.. a complex character / ragdoll?
	-->	.. a complex vehicle (tank, walker, etc.)
	-->	.. a hanging bridge, rope, etc?


-->	Implement Core collision detection logic & sensor colliders
	-->	Colliders will notify their GameObject about OnCollision, OnSeparation and AfterCollision..
	-->	..which will then notify its ICmpCollisionListener Components.
	-->	It may only cache / defer this until it is updated, since all those events aren't meant
		to directly execute user code. It might lead to unexpected behaviour.
	-->	Deferred execution should take place in Collider code, OnXY notifier should directly execute.
		Reason: There might be different kinds of collider components later.
		-->	Collider (default)
		-->	TilemapCollider
			-->	Well, this could actually be just a bool flag for a Tilemap, auto-adjusting a separate collider.
		-->	...

	ICmpCollisionListener API:
	-->	OnCollisionBegin(CollisionData objA, CollisionData objB);
	-->	OnCollisionSolve(CollisionData objA, CollisionData objB, ContactData contact);
	-->	OnCollisionEnd(CollisionData objA, CollisionData objB);
	-->	This is not final. Reconsider it based on actual use cases.
	-->	"CollisionData" is not figured out yet.
		-->	It might contain only Duality-related data and act as if there was no Farseer
		-->	This is preferrable since replacing Farseer with a different physics engine
			won't affect any user code. Encapsulation rulez.

	-->	Collision impact force?
	-->	Collision point relative to object?
	-->	How to interpret Farseer Data?

	-->	What about Joints?
		-->	Any Collider can be attached to the world or any other Collider using Joints.
			This is NOT a scene-hierarchial thing.
		-->	Handle joints as some kind of property of a Collider, since any Joint will be
			attached to at least one Collider.
		-->	WYSIWYG-Editor for those joints as well when CamView in Collider edit mode.
		-->	Complex physical objects can be composed out of several parented GameObjects.
			They can also be done using custom Components, but likely won't.
	
	-->	Is that wanted behaviour? How is Unity doing all that..?

-->	Implement raycasting & stuff (Rebuild some Farseer Example with object click&drag)
-->	Port Asteroids demo to a physics-driven version, without any manual collision detection




-->	Duality Tasks (overall)
	-->	Physics & Collision Detection
	-->	Particle Systems & Particle Editor
	-->	Ingame GUI & GUI Editor
	-->	(Property) Animations & Animation Editor




-->	Isometric perspective: How to implement for a game?
	-->	Should actually use the Z Component, but apply it other than currently
	-->	Maybe just utilize PreprocessCoords to add Z to Y?

-->	Keep in mind: Saving GameObjects with PrefabLinks is currently highly data-redundant.
	-->	When in ExecutionContext.Editor, consider not saving Components that are part of the Prefab.
	-->	Can't do the same with GameObjects though, because their index is used to locate them when applying
		the PrefabLink. Changing the order or removing existing GameObjects requires extra consideration.