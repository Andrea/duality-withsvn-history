
-->	Write Duality's own binary serialization framework (but relating on .NETs serialization interfaces)
	-->	Custom type loader relating to always the newest plugin set
		-->	No need for manual fixups (Get rid of SerializationHelper...)
		-->	No need for a custom Type Binder
	-->	Custom reaction to unavailable types
		-->	Proper recovery from renamed or removed classes!
	-->	Proper use of "NonSerializedPrefabAttribute", probably in a general version like "NonSerializedConditional" or something
	-->	Better to debug


-->	Checklist for first Game: Asteroids
	-->	"You are dead" + enter name if on highscore
	-->	Highscore list in title scene using MetaData
	-->	Upgrades
		-->	Blue:	Permanent
			-->	Front lasers
			-->	Diagonal lasers
			-->	Side lasers
		-->	Green:	Temporary
			-->	Kill all Asteroids
			-->	Make walls bounce projectiles for X seconds
			-->	Double shooting frequency for X seconds
	-->	Music
		-->	Menu, Game, You-Are-Dead



-->	Editor Skeletton
	-->	Sandbox (Play | Pause | Reset)


-->	Keep in mind: Saving GameObjects with PrefabLinks is currently highly data-redundant.
	-->	When in ExecutionContext.Editor, consider not saving Components that are part of the Prefab.
	-->	Can't do the same with GameObjects though, because their index is used to locate them when applying
		the PrefabLink. Changing the order or removing existing GameObjects requires extra consideration.

-->	Keep in mind: Currently, DeepResolveTypeReferences is invoked on ANY loaded Resource, no matter if its loaded
	in the editor or not. 
	-->	This is kind of a "stability hack": In theory, this is only necessary in ExecutionContext.Editor, because Plugins 
		won't change at run-time. However, in practice the user may run the game from the editor and step into a Resource 
		the editor hasn't loaded so far and thus didn't resolve its type references. While it normally works, it will 
		result in undefined behaviour when a core plugin has changed since the Resource has been saved the last time.
	-->	It would be sufficient to resolve type references of all existing Resources at once when building the game for
		release mode i.e. "closing the source code".
	-->	Though, as long as it doesn't become a performance issue, it may stay like this.
	-->	Solution notes, given the case it DOES become a performance issue:
		-->	It would be possible to provide a "plugin hash" in the basic Resource class. Resolving type references
			is only necessary if the current (DualityApp's) plugin hash differs from the one saved in the Resource.
			It might then be performed automatically and also save the Resource again so it won't be necessary a 
			second time until rebuilding plugins again.

-->	Keep in mind: While reloading Core plugins at runtime does work fine in most cases, it might result in
	undefined behaviour when custom Resource types have been modified, as only Prefabs and the current level
	are reloaded.
	-->	Possible solution: Scan the reloaded core plugin for classes deriving from Resource, and clear all
		Resources matching their Type as well.