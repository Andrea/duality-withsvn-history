
-->	Duality Tasks (overall)
	-->	Particle Systems & Particle Editor
	-->	Scripts (Each deriving from Script-Baseclass)
	-->	(Property) Animations & Animation Editor
	-->	??? Ingame GUI & GUI Editor

-->	Dualitor: PerformanceMonitor
-->	Dualitor: Component Wizard
-->	Dualitor: Improve User learning curve
	-->	More Advisor information?
	-->	"Did you know..?" screen?


-->	Object Cloning Issue:
	-->	Currently can't clone cross-references to other objects
	-->	That means, can't create Prefabs from that (Because they're generated by cloning an object)
	-->	Figure out a way to be able to clone cross-references
		-->	## Additional Cloneprovider argument?
			-->	CloneProvider in SerializationHelper class only provides already-cloned objects
				-->	There could a RequestClone-method that is able to generate a cloned version of any object on-the-fly, anytime.
			-->	CloneProvider would need to be integrated into automatic OnCopyTo-implementation
		-->	## Completely rewrite object cloning to use reflection-driven approach?
			-->	How to limit the object graph?
			-->	Also, it might be slow.
		-->	## Implement CloneProvider that accepts clone methods for specific Types and use automatic cloning
			-->	Completely rewrite CloneHelper. Is only used in OnCopyTo anyway.
			-->	Implement a special CloneProvider for cloning GameObjects and Components.
			-->	Test all this in an isolated environment first. Migrate it when finished testing.

			-->	CloneRoot object is provided in order to determine object Graph
				-->	Don't clone GameObject or Component references that are not children of that graph.
				-->	Optionally, even set them null (Prefabs)
			-->	Don't clone or assign Resource references
			-->	What about event fields? Preprocess them to remove external recievers?

			-->	Register custom clone methods for GameObject (CopyTo-like) and Component (CopyTo-like)
			-->	Reqrite automatic OnCopyTo (Component) to use CloneProvider



--> Example Project: Tetris with Physics
	-->	Need Joints for this in order to create partially destructible blocks
	-->	No, actually we don't need Joints for this. As Farseer Joints are solved
		iteratively, they will never be 100% rigid, not even the WeldJoint. To achieve
		100% rigid connections (and improve performance) there should be a single (!)
		body with multiple fixtures where each fixture can be removed individually
		-->	Need a game-specific "BlockRenderer" for that which uses Collider shapes
			to define its form and applies a texture to it.


-->	Reconsider Transform External Updaters
	-->	Would be great if they could be removed. Its inconsistent design and a little hacky.
	-->	What are they doing currently?
		-->	IgnoreParent flag
		-->	Are informed about external (setABC-)changes on update
		-->	Are called on update instead of default velocity calculations
		(+)	Small overhead, distinct job
		(-)	Very specific, seems hacky
		(-)	Distinct job tailored for one specific other Component.. the Collider.
	-->	How can that be achieved otherwise?
		-->	Move IgnoreParent flag to Transform itsself
		-->	Introduce TransformSet event in Transform that may be called on update
		-->	Introduce UpdateTransform event that is called instead of default velocity calculations,
			if any handler is registered.
		(+)	Not as specific, more flexible
		(.)	Events.. is that consistent to the Component concept?
	-->	Reconsider this and choose one.


-->	Example Project: Super Mario style platformer
	-->	Tile-based
	-->	Will need something to edit tilemaps and probably a distinct Tileset Resource
	-->	Component: TilemapRenderer
	-->	Component: TilemapCollider
	-->	Resource: Tileset
		-->	References Material to use
		-->	Defines tile data
			-->	Collision Group (0 == dont collide)
			-->	Collision mask (Top, Bottom, Left, Right) (?)
			-->	Is AutoTile?
			-->	etc.
	-->	CamViewState: Tile Editor (?)
	-->	Is there a way to generalize all this enough to make dynamically lit tilemap rendering
		blend into existing design  smoothly?




--> Physics Thoughts
	-->	What about Joints?
		-->	Any Collider can be attached to the world or any other Collider using Joints.
			This is NOT a scene-hierarchial thing.
		-->	Handle joints as some kind of property of a Collider, since any Joint will be
			attached to at least one Collider.
		-->	WYSIWYG-Editor for those joints as well when CamView in Collider edit mode.
		-->	Complex physical objects can be composed out of several parented GameObjects.
			They can also be done using custom Components, but likely won't.

		-->	Joints
			-->	Probably change Joint concept - use unidirectional code design?
			-->	Assure WeldJoint works 100% (represents Joint system tests)
			-->	Add other Joint types
		-->	Joint Editor
			-->	Make Joints selectable and configurable
			-->	It should be possible to move a Joints contact points, both individually
				-->	Doesn't make any sense for the WeldJoint.
				-->	Also, doesn't make any sense for most or all other Joints.
				-->	They generally have one anchor point (if any), not two.
				-->	Cut out Joint selection and editing from the ColliderView alltogether?
				-->	Configure Joints in the Collider via PropertyGrid similar to SoundEmitter?
					-->	How to add them?
					-->	Using a special PropertyEditor?
			-->	Make sure everything updates properly

	-->	How would you do.. (All those should be possible in some way!)
		-->	.. a platformer with moving platforms?
		-->	.. an Rpg using Tilemaps?
		-->	.. a complex character / ragdoll?
		-->	.. a complex vehicle (tank, walker, etc.)
		-->	.. a hanging bridge, rope, etc?




		
		
		
-->	Concept for "Component Wizard" dialog / editor:
	Das bezieht sich natürlich nicht auf deinen Grundgedanken sondern auf die Implikationen, welche das Bild das ich vom Feature Request insgesamt gewonnen habe mit sich bringt. Insofern würd ich erstmal sagen "Nein, so in der Form halte ich das für keine gute Idee", was aber nichts am Problem ändert das dein Feature hätte lösen sollen. Folgendes wäre ein alternativer Ansatz, den ich mir gut vorstellen könnte:

	--> Implementierung eines neuen Sub-Editors oder Dialogfelds, dem "Component Wizard" (o.Ä.)
	--> Aufgabe dessen ist es, auf Basis einiger Angaben, z.B. einer Auflistung von Property-Definitionen eine Komponentenklasse im Projekt zu erstellen. 
	--> Dabei können dann auch so Späße getrieben werden wie automatisch die Backend-Fields generieren, triviale Getter und Setter implementieren und sowas. Das Ergebnis wird als .cs-Code File im Projekt abgelegt und über Bearbeitung der Projektdatei automatisch hinzugefügt.
	--> Wenn es mir gelingt, über Dualitor Visual Studio dazu zu bewegen, ein bestimmtes Projekt neu zu kompilieren, dann könnte der Component Wizard auch das automatisch veranlassen, sobald die neue Komponentenklasse erstellt wurde
	--> Ist letzteres der Fall wäre es denkbar, im Editor einige Shortcuts einzufügen, die den Component Wizard aufrufen, z.B. direkt im PropertyGrid oder als Rechtsklick-Aktion auf ein GameObject. 

	Im Idealfall wäre der Ablauf also:
	1. GameObject (z.B. Asteroid) erstellen und damit rumbasteln bis zufrieden
	2. Rechtsklick auf GameObject --> "Add custom Component" --> Component Wizard wird aufgerufen
	3. Gewünschte Konfiguration im Component Wizard festlegen
	4. Klick auf "Ok" sorgt für Neukompilierung des Core Plugins, was automatisch zum Neuladen dieses führt
	5. Anschließend kann der neue Komponententyp per Reflection gefunden und automatisch an das GameObject angefügt werden.

	Die Schritte 4 und 5 können natürlich nur umgesetzt werden, wenn ich diese Sache mit Visual Studio ansteuern hinbekomme. Mir ist zwar klar dass ich auch programmatisch ohne Probleme C# Code kompilieren kann, aber effektiv würde ich mit dem manuellen Versuch schon wieder eine neue Baustelle für mögliche Inkonsistenzen einführen, falls ich ein bestimmtes Verhalten in Bezug auf Projektkonfiguration falsch (oder anders als Visual Studio) emuliere. Von daher würde ich hier klar sagen "entweder VS selbst kompilieren lassen oder gar nicht".
		
		
		
		
		


-->	Isometric perspective: How to implement for a game?
	-->	Should actually use the Z Component, but apply it other than currently
	-->	Maybe just utilize PreprocessCoords to add Z to Y?
		-->	Will that work in all cases? Editor? Canvas? Any Renderer?
	-->	Is it really necessary to adjust the Camera? Isn't it possible to 
		adjust objects and rendering setup on the Game-side?

-->	Keep in mind: Saving GameObjects with PrefabLinks is currently highly data-redundant.
	-->	When in ExecutionContext.Editor, consider not saving Components that are part of the Prefab.
	-->	Can't do the same with GameObjects though, because their index is used to locate them when applying
		the PrefabLink. Changing the order or removing existing GameObjects requires extra consideration.


############### HOWTO: Obtain the Z-Pos of a rendered pixel relative to the Camera ###############

//Vector3 screenPos = new Vector3(0.5f, 0.5f, 0.0f);
//GL.ReadPixels(this.pickingTex.PxWidth / 2, this.pickingTex.PxHeight / 2, 1, 1, PixelFormat.DepthComponent, PixelType.Float, ref screenPos.Z);
//screenPos -= Vector3.One * 0.5f;
//screenPos *= 2.0f;
//Matrix4 matTemp = this.matFinal;
//matTemp.Invert();
//Vector3.Transform(ref screenPos, ref matTemp, out screenPos);
//Log.Editor.Write("{0:F},\t{1:F},\t{2:F}", screenPos.X, screenPos.Y, screenPos.Z);