
-->	Implement collision detection logic & sensor colliders
	-->	Colliders will notify their GameObject about OnCollision, OnSeparation and AfterCollision..
	-->	..which will then notify its ICmpCollisionListener Components.
	-->	It may only cache / defer this until it is updated, since all those events aren't meant
		to directly execute user code. It might lead to unexpected behaviour.

	ICmpCollisionListener API:
	-->	OnCollisionBegin(CollisionData objA, CollisionData objB);
	-->	OnCollisionSolve(CollisionData objA, CollisionData objB, ContactData contact);
	-->	OnCollisionEnd(CollisionData objA, CollisionData objB);
	-->	This is not final. Reconsider it based on actual use cases.
	-->	"CollisionData" is not figured out yet.
		-->	It might contain only Duality-related data and act as if there was no Farseer
		-->	This is preferrable since replacing Farseer with a different physics engine
			won't affect any user code. Encapsulation rulez.

	Issues:
	-->	Provide a WYSIWYG-Editor for Collider Shapes in the editor
		-->	Needs special CamView-editing plugin features.
			-->	Introduce CamViewState class that essentially handles CamView editing
			-->	CamView movement is done in CamView, everything else will be handled by the CamViewState.
			-->	The default CamViewState does object selection and transform changes (just like now)
			-->	There will be a different CamViewState that only does Collider editing
			-->	Switching between states can be done using a ComboBox or something.
				-->	Don't show states that aren't available right now
				-->	Grey out the ComboBox, if no other state is available
			-->	CamViewStates are registered in the CorePluginHelper and cloned to instantiate them
				in the respective CamView.
			-->	Each CamView needs to save its current state to editor user data
		-->	Actual editor:
			-->	Preview shape in view
				-->	Display a shapes density numeric (absolute value) and visually as fill transparency (relative to other shapes)
			-->	Edit shape in view
				-->	Circles
				-->	Polygons
					-->	May be any kind of shape and vertex number.
					-->	Use some kind of decomposition (internally!) to create a set of valid Farseers polygons.
			-->	View rotation is considered

	-->	Collision impact force?
	-->	Collision point relative to object?
	-->	How to interpret Farseer Data?

	-->	What about Joints?
		-->	Any Collider can be attached to the world or any other Collider using Joints.
			This is NOT a scene-hierarchial thing.
		-->	Handle joints as some kind of property of a Collider, since any Joint will be
			attached to at least one Collider.
		-->	WYSIWYG-Editor for those joints as well when CamView in Collider edit mode.
		-->	Complex physical objects can be composed out of several parented GameObjects.
			They can also be done using custom Components, but likely won't.
	
	-->	Is that wanted behaviour? How is Unity doing all that..?

-->	Implement raycasting & stuff (Rebuild some Farseer Example with object click&drag)
-->	Port Asteroids demo to a physics-driven version, without any manual collision detection




-->	Duality Tasks (overall)
	-->	Editor Sandbox (Play | Pause | Reset)
	-->	Physics & Collision Detection
	-->	Particle Systems & Particle Editor
	-->	Ingame GUI & GUI Editor
	-->	(Property) Animations & Animation Editor




-->	Keep in mind: Saving GameObjects with PrefabLinks is currently highly data-redundant.
	-->	When in ExecutionContext.Editor, consider not saving Components that are part of the Prefab.
	-->	Can't do the same with GameObjects though, because their index is used to locate them when applying
		the PrefabLink. Changing the order or removing existing GameObjects requires extra consideration.